#!/usr/bin/perl -w

#------------------------------------------------------------------------------
#          Harvard University Atmospheric Chemistry Modeling Group            !
#------------------------------------------------------------------------------
#BOP
#
# !MODULE: gcUnitTest
#
# !DESCRIPTION: This perl script is the driver for the GEOS-Chem Unit Tester,
#  which submits several automatic debugging jobs.
#\\
#\\
# !USES:
#
require 5.003;                       # Need this version of Perl or newer
use English;                         # Use English language
use Carp;                            # Get detailed error messages
use strict;
use Dates   qw( &getLocalTime  );    # Get routines from Dates.pm
use UtUtils qw( &baseName
                &checkDir
                &cleanDir
                &makeInputGeos
                &parse         );    # Get routines from UtUtils.pm
#
# !PUBLIC DATA MEMBERS:
#

# Directories
our $CODE_DIR  = "";                 # GEOS-Chem Code directory 
our $DATA_ROOT = "";                 # Root path for GEOS-Chem data directory
our $JOB_DIR   = "";                 # Unit Test job directory
our $LOG_DIR   = "";                 # Unit Test logs directory
our $PERL_DIR  = "";                 # Unit Test Perl directory
our $RUN_DIR   = "";                 # Unit Test run directory

# Options
our $COMPILER  = "";                 # Compiler variable for GEOS-Chem
our $MAKE_CMD  = "";                 # Make command with debug options
our $SUBMIT    = "";                 # Queue submit command
our $VERSION   = "";                 # GEOS-Chem version ID
#		
# !PUBLIC MEMBER FUNCTIONS:
#  &main()     : Driver routine for gcUnitTest
#
# !PRIVATE MEMBER FUNCTIONS:
#  &getRunDir  : Returns the name of the GEOS-Chem run directory
#  &makeInputs : Creates the input.geos file the run directory 
#  &doUnitTest : Reads user options from a file and starts the unit test
#
# !CALLING SEQUENCE:
#  gcUnitTest [ OPTIONS-FILENAME ]
#
# !REMARKS:
#  If no value is passed for OPTIONS-FILENAME, then gcUnitTest will
#  read user options from the input file: "UnitTest.input".
#
# !REVISION HISTORY: 
#  22 Aug 2013 - R. Yantosca - Initial version
#EOP
#------------------------------------------------------------------------------
#          Harvard University Atmospheric Chemistry Modeling Group            !
#------------------------------------------------------------------------------
#BOP
#
# !IROUTINE: getRunDir
#
# !DESCRIPTION: Returns the unit test run directory for a given combination
#  of met field, grid, simulation type, and nested-grid type.
#\\
#\\
# !INTERFACE:
#
sub getRunDir($$$$) {
#
# !INPUT PARAMETERS:
#
  # $met  : Met field type
  # $grid : Horiziontal grid
  # $nest : Nested grid option (if necessary)
  # $sim  : Simulation type
  my ( $met, $grid, $nest, $sim ) = @_;
#
# !RETURN VALUE:
#
  my $runDir = ""; 
#
# !CALLING SEQUENCE:
#  &doUnitTest( "UnitTest.input" );
#
# !REVISION HISTORY:
#  22 Aug 2013 - R. Yantosca - Initial version
#EOP
#------------------------------------------------------------------------------
#BOC
#
# !LOCAL VARIABLES:
#
  # Run directory string
  my $runLoc = "{MET}_{GRID}_{SIM}";

  # Append nested grid string if necessary
  if ( !( $nest =~ m/\-/ )  ) { $runLoc .= "_{NEST}"; }

  # Replace tokens
  $runLoc =~ s/{MET}/$met/g;
  $runLoc =~ s/{GRID}/$grid/g;
  $runLoc =~ s/{SIM}/$sim/g;
  $runLoc =~ s/{NEST}/$nest/g;
  $runDir = "$RUN_DIR";
  $runDir =~ s/{RUNDIR}/$runLoc/g;

  # Return the run directory
  return( $runDir );
}
#EOP
#------------------------------------------------------------------------------
#          Harvard University Atmospheric Chemistry Modeling Group            !
#------------------------------------------------------------------------------
#BOP
#
# !IROUTINE: makeInputs
#
# !DESCRIPTION: Creates the input.geos file in a unit-test run-directory.
#  It starts with a template file and then replaces some tokens to customize
#  the input.geos file for the given simulation.
#\\
#\\
# !INTERFACE:
#
sub makeInputs($$$) {
#
# !INPUT PARAMETERS:
#
  # $start  : Start date of test simulation (YYYYMMDDhh)
  # $end    : End   date of test simulation (YYYYMMDDhh)
  # $runDir : Run directory
  my ( $start, $end, $runDir ) = @_;
#
# !CALLING SEQUENCE:
#  &makeInputFiles( $start, $end, $runDir );
#
# !REVISION HISTORY:
#  22 Aug 2013 - R. Yantosca - Initial version
#EOP
#------------------------------------------------------------------------------
#BOC
#
# !LOCAL VARIABLES:
#
  my $d0      = "";
  my $h0      = "";
  my $d1      = "";
  my $h1      = "";
  my $inpTmpl = "$runDir/input.geos.template";
  my $inpGeos = "$runDir/input.geos";

  # Get start date and hour
  $d0       = substr( $start, 0, 8 );
  $h0       = substr( $start, 8, 2 );
  $h0      .= "0000";

  # Get end date and hour
  $d1       = substr( $end,   0, 8 );
  $h1       = substr( $end,   8, 2 );
  $h1      .= "0000";

  # Make the input.geos file in the run directory
  &makeInputGeos( $d0, $h0, $d1, $h1, $DATA_ROOT, $inpTmpl, $inpGeos );

  # Return 
  return( $? );
}
#EOP
#------------------------------------------------------------------------------
#          Harvard University Atmospheric Chemistry Modeling Group            !
#------------------------------------------------------------------------------
#BOP
#
# !IROUTINE: doUnitTest
#
# !DESCRIPTION: Reads the input file name (containing user-specified options)
#  file and creates a job script.  The job script (which can be submitted to
#  a computational queue) will be used to call Makefiles to compile and run 
#  GEOS-Chem with debugging options.
#\\
#\\
# !INTERFACE:
#
sub doUnitTest($) {
#
# !INPUT PARAMETERS:
#
  my ( $fileName ) = @_;  # File in which unit test options are listed
#
# !CALLING SEQUENCE:
#  &doUnitTest( $fileName );
#
# !REVISION HISTORY:
#  22 Aug 2013 - R. Yantosca - Initial version, based on sleepNrt
#  27 Aug 2013 - R. Yantosca - Now add $PERL_DIR to the make command
#  28 Aug 2013 - R. Yantosca - Now call &cleanDir from UtUtils.pm
#  28 Aug 2013 - R. Yantosca - Minor bug fixes.  Also now send results
#                              to a separate file from stdout.
#  29 Aug 2013 - R. Yantosca - Make sure that $met, $grid, $nest are in
#                              lowercase, regardless of input
#EOP
#------------------------------------------------------------------------------
#BOC
#
# !LOCAL VARIABLES:
#
  # Scalar
  my $cmd     = "";
  my $end     = "";
  my $grid    = "";
  my $jobFile = "";
  my $logHdr  = "";
  my $logRslt = "";
  my $logTop  = "";
  my $met     = "";
  my $makeCmd = ""; 
  my $nest    = "";
  my $notDir  = "";
  my $runDir  = "";
  my $sim     = "";
  my $status  = "";
  my $stdout  = "";
  my $start   = "";
  my $locTime = "";

  # Arrays
  my @cmds    = ();
  my @txt     = ();

  #---------------------------------------------------------------------------
  # Read options from the input file
  #---------------------------------------------------------------------------
  
  # Read entire file into an array and remove newlines
  open( I, "<$fileName" ) or die "Cannot open $fileName!\n";
  chomp( @txt = <I> );
  close( I );

  # Loop thru each line in the file; parse information into global variables
  for ( my $i = 0; $i < scalar( @txt ); $i++ ) {

    #------------------------------------------------------------------------
    # Get values for global options (these precede the list of simulations)
    # Skip over lines beginning with the # comment character
    #------------------------------------------------------------------------
    if ( !( $txt[$i] =~ m/\#/ ) ) { 
      if    ( $txt[$i] =~ "CODE_DIR"  ) { $CODE_DIR  = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "COMPILER"  ) { $COMPILER  = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "DATA_ROOT" ) { $DATA_ROOT = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "JOB_DIR"   ) { $JOB_DIR   = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "LOG_DIR"   ) { $LOG_DIR   = &parse( $txt[$i] ); }
      elsif ( $txt[$i] =~ "MAKE_CMD"  ) { $MAKE_CMD  = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "PERL_DIR"  ) { $PERL_DIR  = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "RUN_DIR"   ) { $RUN_DIR   = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "SUBMIT"    ) { $SUBMIT    = &parse( $txt[$i] ); } 
      elsif ( $txt[$i] =~ "VERSION"   ) { $VERSION   = &parse( $txt[$i] ); }
    }

    #------------------------------------------------------------------------
    # Get information about requested debug simulatons
    # and create the make commands corresponding to each simulation
    #------------------------------------------------------------------------
    elsif ( $txt[$i] =~ "!RUNS"     ) {

      # Make sure each of these directories exist before proceeding
      &checkDir( $DATA_ROOT );
      &checkDir( $CODE_DIR  );
      &checkDir( $JOB_DIR   );
      &checkDir( $LOG_DIR   );
      &checkDir( $PERL_DIR  );
     
      # Skip over comment lines
      while ( $txt[$i] =~ m/^\#/ ) { $i++ }

      # Loop over all requested simulations
      while ( !($txt[$i] =~ m/END/ ) ) { 

	# Skip lines beginning with comments
	if ( !( $txt[$i] =~ m/^\#/ ) ) {

	  # Parse each line into values
	  ( $met, $grid, $nest, $sim, $start, $end ) = split( ' ', $txt[$i] );

	  # Make sure met, grid, nest are in lowercase
	  $met     =~ tr/[A-Z]/[a-z]/;
	  $grid    =~ tr/[A-Z]/[a-z]/;
	  $nest    =~ tr/[A-Z]/[a-z]/;

	  # Remove extraneous characters from $met
	  $met     =~ s/\-//g;
	  $met     =~ s/\_//g;
	  $met     =~ s/\=//g;
	  $met     =~ s/\.//g;

	  # Define the run directory name
	  $runDir   = &getRunDir( $met, $grid, $nest, $sim );
	  &checkDir( $runDir );

	  # Get the directory name minus the full path
	  $notDir   = &baseName( $runDir );

	  # Construct the make command, for single & multi processor
	  $makeCmd  = "$MAKE_CMD COMPILER=$COMPILER MET=$met GRID=$grid";
	  $makeCmd .= " SIM=$sim VERSION=$VERSION LOG_DIR=$LOG_DIR";
	  $makeCmd .= " CODE_DIR=$CODE_DIR PERL_DIR=$PERL_DIR";
	  $makeCmd .= " START=$start END=$end"; 

	  # The main log file
	  $stdout   = "$LOG_DIR/$VERSION.stdout.log";
	  $logRslt  = "$LOG_DIR/$VERSION.results.log";

	  # If necessary, also add on the nested grid flags
	  if ( !( $nest =~ m/\-/ ) ) { $makeCmd .= " NEST=$nest"; }
	
	  # Make the input.geos file in the run directory
	  &makeInputs( $start, $end, $runDir );

	  # Save make commands to an array for use below
	  @cmds = ( @cmds, "\n\n\# %%% $notDir %%%\n",
		           "cd $runDir >> $stdout\n\n",
		           "$makeCmd unittest >> $stdout\n" );
        }

	# Increment counter
	$i++;


      }
    }	
  }

  #--------------------------------------------------------------------------
  # Write a script to call Makefiles in each of the run directories
  # that will compile and run GEOS-Chem with debugging options
  #--------------------------------------------------------------------------

  # Remove all files in the job & log dir
  &cleanDir( $JOB_DIR );
  &cleanDir( $LOG_DIR );

  # Get local time
  $locTime = &getLocalTime();

  # Make some text for the top of the log file that will hold results
  $logHdr = "%" x 79;
  $logTop = <<EOF;
echo "$logHdr"                                                 >> $logRslt
echo "%%%"                                                     >> $logRslt
echo "%%%  GEOS-CHEM UNIT TEST RESULTS FOR VERSION: $VERSION"  >> $logRslt
echo "%%%  job sent to queue at $locTime"                      >> $logRslt
echo "%%%"                                                     >> $logRslt
echo "%%%  This is the main log file, which shows output from" >> $logRslt
echo "%%%  each individual phase of the unit test sequence."   >> $logRslt
echo "%%%"                                                     >> $logRslt
echo "%%%  Log files from individual unit-test runs are also"  >> $logRslt
echo "%%%  stored in this same directory."                     >> $logRslt
echo "%%%"                                                     >> $logRslt
echo "$logHdr"                                                 >> $logRslt
EOF

  # Add some more commands to the top of the job script
  @cmds = ( '#!/bin/bash'."\n",
            "set \-e\n", 
	    "$logTop\n", 
            @cmds               );

  # WRITE the make commands to a job file
  $jobFile = "$JOB_DIR/job.$VERSION";
  open( O, ">$jobFile" ) or die "Cannot open $jobFile!\n";
  print O @cmds;
  close( O );
  chmod( 0755, $jobFile );

  # Print
  print "Created job file $jobFile\n";

  # Submit the job.  Send the stdout stream to $logRslt
  # and the stderr stream to a file in the $LOG_DIR.
  $cmd = "cd $LOG_DIR; $SUBMIT $jobFile\n";
  chomp( $status = qx( $cmd ) );
  print "$status\n";
  				
  # Return normally
  return( $? );
}
#EOP
#------------------------------------------------------------------------------
#          Harvard University Atmospheric Chemistry Modeling Group            !
#------------------------------------------------------------------------------
#BOP
#
# !IROUTINE: main
#
# !DESCRIPTION: Driver program for the gcUnitTest script.
#\\
#\\
# !INTERFACE:
#
sub main(@) {
#
# !CALLING SEQUENCE:
#  doUnitTest OPTIONS-FILENAME
#
# !REVISION HISTORY:
#  23 May 2013 - R. Yantosca - Initial version, based on NRT-ARCTAS
#EOP
#------------------------------------------------------------------------------
#BOC
#
  # If the user passes a filename from the command line, use it
  # Otherwise, default to "UnitTest.input"
  if ( scalar( @ARGV ) == 1 ) { &doUnitTest( $ARGV[0]         ); }
  else                        { &doUnitTest( "UnitTest.input" ); }

  # Exit and pass status code back
  return( $? );
}
#EOC
#------------------------------------------------------------------------------

# Call main program
main();

# Exit and pass status code back to Unix shell
exit( $? );


